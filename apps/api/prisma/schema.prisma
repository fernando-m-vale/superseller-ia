// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  owner
  manager
  operator
}

enum Marketplace {
  shopee
  mercadolivre
  amazon
  magalu
}

enum ConnectionStatus {
  active
  expired
  revoked
  reauth_required
}

enum ListingStatus {
  active
  paused
  deleted
}

enum ListingAccessStatus {
  accessible
  unauthorized
  blocked_by_policy
}

enum QualityStatus {
  pass
  warning
  critical
}

enum JobStatus {
  success
  error
  running
}

enum JobType {
  shopee_sync
  mercadolivre_sync
  mercadolivre_orders_sync
  amazon_sync
  magalu_sync
  metrics_aggregation
  data_quality_check
}

enum OrderStatus {
  pending
  paid
  shipped
  delivered
  cancelled
  refunded
}

enum RuleStatus {
  active
  inactive
}

enum ActionType {
  title_optimization
  image_audit
  attribute_completion
  price_adjustment
  stock_update
}

enum RecommendationType {
  seo // Otimização de título/descrição
  image // Melhoria de imagens
  price // Ajuste de preço
  conversion // Melhoria de conversão
  stock // Gestão de estoque
  content // Conteúdo geral
}

enum RecommendationStatus {
  pending // Aguardando ação do usuário
  applied // Usuário aplicou a recomendação
  dismissed // Usuário ignorou
  expired // Expirou (anúncio mudou)
}

enum SyncStatus {
  idle
  running
  success
  error
}

enum SyncJobType {
  TENANT_SYNC
  LISTING_SYNC
}

enum SyncJobStatus {
  queued
  running
  success
  error
  skipped
}

enum SyncJobPriority {
  interactive
  background
}

// Models
model Tenant {
  id         String   @id @default(uuid())
  name       String
  created_at DateTime @default(now())

  // DIA 08: Campos de sync automático (HOTFIX: timestamptz para timezone consistente)
  last_auto_sync_at     DateTime?  @db.Timestamptz(3)
  last_manual_sync_at   DateTime?  @db.Timestamptz(3)
  last_sync_status      SyncStatus @default(idle)
  last_sync_error       String?    @db.Text
  last_sync_started_at  DateTime?  @db.Timestamptz(3)
  last_sync_finished_at DateTime?  @db.Timestamptz(3)

  users                   User[]
  marketplace_connections MarketplaceConnection[]
  listings                Listing[]
  orders                  Order[]
  listing_metrics_daily   ListingMetricsDaily[]
  ai_model_metrics        AiModelMetric[]
  data_quality_checks     DataQualityCheck[]
  job_logs                JobLog[]
  auto_approve_rules      AutoApproveRule[]
  listing_action_outcomes ListingActionOutcome[]
  recommendations         Recommendation[]
  listing_ai_analysis     ListingAIAnalysis[]
  applied_actions         AppliedAction[]
  sync_jobs               SyncJob[]
  ListingHack             ListingHack[]

  @@map("tenants")
}

model User {
  id            String   @id @default(uuid())
  tenant_id     String
  email         String   @unique
  password_hash String
  role          UserRole
  created_at    DateTime @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([tenant_id])
  @@map("users")
}

model MarketplaceConnection {
  id                  String           @id @default(uuid())
  tenant_id           String
  type                Marketplace
  provider_account_id String
  access_token        String
  refresh_token       String?
  expires_at          DateTime?
  status              ConnectionStatus
  last_error_code     String? // Código do último erro HTTP (ex: "401", "403")
  last_error_at       DateTime? // Quando ocorreu o último erro
  last_error_message  String? // Mensagem do último erro (sanitizada)
  created_at          DateTime         @default(now())
  updated_at          DateTime         @updatedAt

  tenant   Tenant    @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listings Listing[] // Listings sincronizados por esta conexão

  @@unique([tenant_id, type, provider_account_id])
  @@index([tenant_id])
  @@map("marketplace_connections")
}

model Listing {
  id                        String              @id @default(uuid())
  tenant_id                 String
  marketplace               Marketplace
  listing_id_ext            String
  marketplace_connection_id String? // FK para marketplace_connections (identifica qual conexão criou/sincronizou)
  seller_id                 String? // ID do seller no ML (obtido via GET /items/:id para auditoria)
  title                     String
  description               String? // Descrição do anúncio para análise
  price                     Decimal             @db.Decimal(10, 2)
  price_final               Decimal?            @db.Decimal(10, 2) // Preço final (com promoção, se houver)
  original_price            Decimal?            @db.Decimal(10, 2) // Preço original antes da promoção
  has_promotion             Boolean             @default(false) // Tem promoção ativa?
  discount_percent          Int? // Percentual de desconto (0-100)
  promotion_type            String? // Tipo de promoção (ex: "flash_sale", "discount", "free_shipping")
  promotion_checked_at      DateTime? // Quando foi verificada a promoção
  pictures_json             Json? // Array completo de pictures do ML com secure_url etc.
  stock                     Int
  status                    ListingStatus
  category                  String?
  health_score              Float?              @default(0) // Score legado da API do ML (0-100)
  super_seller_score        Int?                @default(0) // Super Seller Score proprietário (0-100)
  score_breakdown           Json? // Detalhamento: { cadastro: 25, trafego: 20, disponibilidade: 35 }
  thumbnail_url             String? // URL da imagem principal
  pictures_count            Int?                @default(0) // Quantidade de fotos
  has_video                 Boolean?            @default(false) // Tem vídeo? (baseado em video_id/videos do payload)
  has_clips                 Boolean? // Tem clips? (null = desconhecido/não detectável via API)
  clips_source              String? // Fonte: "unknown" | "override" | "api"
  clips_checked_at          DateTime? // Quando foi verificado/atualizado
  variations_count          Int?                @default(0) // Quantidade de variações do anúncio (ex: cores, tamanhos)
  visits_last_7d            Int?                @default(0) // Visitas últimos 7 dias
  sales_last_7d             Int?                @default(0) // Vendas últimos 7 dias
  source                    String? // Origem da ingestão: "discovery" | "orders_fallback" | null
  discovery_blocked         Boolean             @default(false) // Se discovery foi bloqueado (403/PolicyAgent)
  access_status             ListingAccessStatus @default(accessible) // Status de acesso pela conexão atual
  access_blocked_code       String? // Código do erro que bloqueou acesso (ex: "PA_UNAUTHORIZED_RESULT_FROM_POLICIES")
  access_blocked_at         DateTime? // Quando foi bloqueado
  access_blocked_reason     String? // Mensagem sanitizada do erro (sem token)
  // DIA 08: Campos de sync por listing (HOTFIX: timestamptz para timezone consistente)
  last_synced_at            DateTime?           @db.Timestamptz(3)
  last_sync_status          SyncStatus          @default(idle)
  last_sync_error           String?             @db.Text
  created_at                DateTime            @default(now())
  updated_at                DateTime            @updatedAt

  tenant                  Tenant                 @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  marketplace_connection  MarketplaceConnection? @relation(fields: [marketplace_connection_id], references: [id], onDelete: SetNull)
  listing_metrics_daily   ListingMetricsDaily[]
  listing_action_outcomes ListingActionOutcome[]
  order_items             OrderItem[]
  recommendations         Recommendation[]
  listing_ai_analysis     ListingAIAnalysis[]
  applied_actions         AppliedAction[]
  listing_hacks           ListingHack[]

  @@unique([tenant_id, marketplace, listing_id_ext])
  @@index([tenant_id])
  @@index([tenant_id, marketplace])
  @@index([tenant_id, status])
  @@index([tenant_id, marketplace_connection_id])
  @@index([marketplace_connection_id])
  @@index([access_status])
  @@index([super_seller_score])
  @@map("listings")
}

model Order {
  id             String      @id @default(uuid())
  tenant_id      String
  marketplace    Marketplace
  order_id_ext   String // ID do pedido no marketplace (ex: ML order ID)
  status         OrderStatus
  total_amount   Decimal     @db.Decimal(12, 2)
  currency       String      @default("BRL")
  buyer_nickname String?
  buyer_id_ext   String? // ID do comprador no marketplace
  shipping_cost  Decimal?    @db.Decimal(10, 2)
  order_date     DateTime // Data do pedido no marketplace
  paid_date      DateTime? // Data do pagamento
  shipped_date   DateTime? // Data de envio
  delivered_date DateTime? // Data de entrega
  created_at     DateTime    @default(now())
  updated_at     DateTime    @updatedAt

  tenant Tenant      @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  items  OrderItem[]

  @@unique([tenant_id, marketplace, order_id_ext])
  @@index([tenant_id])
  @@index([tenant_id, marketplace])
  @@index([tenant_id, status])
  @@index([order_date])
  @@map("orders")
}

model OrderItem {
  id             String   @id @default(uuid())
  order_id       String
  listing_id     String? // Pode ser null se o listing foi deletado
  listing_id_ext String // ID do item no marketplace
  title          String
  quantity       Int
  unit_price     Decimal  @db.Decimal(10, 2)
  total_price    Decimal  @db.Decimal(10, 2)
  created_at     DateTime @default(now())

  order   Order    @relation(fields: [order_id], references: [id], onDelete: Cascade)
  listing Listing? @relation(fields: [listing_id], references: [id], onDelete: SetNull)

  @@index([order_id])
  @@index([listing_id])
  @@map("order_items")
}

model ListingMetricsDaily {
  id          String   @id @default(uuid())
  tenant_id   String
  listing_id  String
  date        DateTime @db.Date
  impressions Int? // Nullable: null = não disponível (sem estimativas)
  clicks      Int? // Nullable: null = não disponível (sem estimativas)
  ctr         Decimal? @db.Decimal(5, 4) // Nullable: null = não disponível (sem estimativas)
  visits      Int? // Nullable: null = unknown, 0 = zero real
  conversion  Decimal? @db.Decimal(5, 4) // Nullable quando visits é null
  orders      Int      @default(0)
  gmv         Decimal  @db.Decimal(10, 2)
  source      String? // Origem: 'ml_orders_period' | 'ml_visits_period' | 'unknown' | 'ml_items_aggregate'
  period_days Int? // Período agregado (ex: 30 para agregado de 30 dias)
  created_at  DateTime @default(now())

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, listing_id, date])
  @@index([tenant_id])
  @@index([listing_id])
  @@index([date])
  @@map("listing_metrics_daily")
}

model AiModelMetric {
  id            String   @id @default(uuid())
  tenant_id     String
  model_version String   @default("v1.1")
  mae           Decimal  @db.Decimal(10, 4)
  rmse          Decimal  @db.Decimal(10, 4)
  r_squared     Decimal  @db.Decimal(5, 4)
  training_date DateTime
  samples_count Int
  features_used String[]
  metadata      Json?
  created_at    DateTime @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([tenant_id])
  @@index([model_version])
  @@index([training_date])
  @@map("ai_model_metrics")
}

model DataQualityCheck {
  id               String        @id @default(uuid())
  tenant_id        String
  check_date       DateTime      @db.Date
  status           QualityStatus
  missing_days     Int           @default(0)
  outlier_count    Int           @default(0)
  total_listings   Int
  listings_checked Int
  issues_found     Json?
  created_at       DateTime      @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, check_date])
  @@index([tenant_id])
  @@index([check_date])
  @@index([status])
  @@map("data_quality_checks")
}

model JobLog {
  id                String    @id @default(uuid())
  tenant_id         String
  job_type          JobType
  status            JobStatus
  started_at        DateTime
  completed_at      DateTime?
  duration_ms       Int?
  records_processed Int?
  error_message     String?
  metadata          Json?
  created_at        DateTime  @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([tenant_id])
  @@index([job_type])
  @@index([status])
  @@index([started_at])
  @@map("job_logs")
}

model AutoApproveRule {
  id                 String     @id @default(uuid())
  tenant_id          String
  name               String
  description        String?
  status             RuleStatus @default(active)
  ctr_threshold      Decimal?   @db.Decimal(5, 4)
  cvr_threshold      Decimal?   @db.Decimal(5, 4)
  revenue_impact_min Decimal?   @db.Decimal(10, 2)
  dry_run            Boolean    @default(true)
  created_at         DateTime   @default(now())
  updated_at         DateTime   @updatedAt

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([tenant_id])
  @@index([status])
  @@map("auto_approve_rules")
}

model ListingActionOutcome {
  id                  String     @id @default(uuid())
  tenant_id           String
  listing_id          String
  action_id           String
  action_type         ActionType
  executed_at         DateTime
  ctr_before          Decimal?   @db.Decimal(5, 4)
  ctr_after           Decimal?   @db.Decimal(5, 4)
  cvr_before          Decimal?   @db.Decimal(5, 4)
  cvr_after           Decimal?   @db.Decimal(5, 4)
  revenue_before      Decimal?   @db.Decimal(10, 2)
  revenue_after       Decimal?   @db.Decimal(10, 2)
  effectiveness_score Decimal?   @db.Decimal(5, 2)
  created_at          DateTime   @default(now())

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, action_id])
  @@index([tenant_id])
  @@index([listing_id])
  @@index([action_type])
  @@index([executed_at])
  @@map("listing_action_outcomes")
}

model Recommendation {
  id              String               @id @default(uuid())
  tenant_id       String
  listing_id      String
  type            RecommendationType
  status          RecommendationStatus @default(pending)
  priority        Int                  @default(50) // 1-100, maior = mais urgente
  title           String // Ex: "Melhore a qualidade das imagens"
  description     String // Descrição detalhada da ação
  impact_estimate String? // Ex: "+15% conversão esperada"
  rule_trigger    String? // Ex: "pictures_count < 3"
  score_impact    Int? // Quantos pontos o anúncio pode ganhar
  metadata        Json? // Dados extras para a UI
  applied_at      DateTime? // Quando foi aplicada
  dismissed_at    DateTime? // Quando foi ignorada
  created_at      DateTime             @default(now())
  updated_at      DateTime             @updatedAt

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, listing_id, type, rule_trigger]) // Evita duplicatas
  @@index([tenant_id])
  @@index([listing_id])
  @@index([tenant_id, status])
  @@index([type])
  @@index([priority])
  @@map("recommendations")
}

// Cache de análise IA por listing + fingerprint
// Evita chamadas repetidas à OpenAI quando dados não mudaram
model ListingAIAnalysis {
  id             String   @id @default(uuid())
  tenant_id      String
  listing_id     String
  period_days    Int      @default(30) // Período de métricas usado na análise
  fingerprint    String // SHA256 hash dos dados relevantes (listing + metrics + prompt_version)
  model          String   @default("gpt-4o") // Modelo usado na análise
  prompt_version String   @default("ai-v1.2") // Versão do prompt para invalidar cache quando mudar
  result_json    Json // Resultado completo da análise (AIAnalysisResult + score)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, listing_id, period_days, fingerprint]) // Cache key única
  @@index([tenant_id])
  @@index([listing_id])
  @@index([fingerprint])
  @@map("listing_ai_analysis")
}

model AppliedAction {
  id             String   @id @default(uuid())
  tenant_id      String
  listing_id     String
  action_type    String // "seo" | "midia" | "cadastro" | "competitividade"
  before_payload Json
  after_payload  Json
  applied_at     DateTime @default(now())
  created_at     DateTime @default(now())

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, listing_id, action_type]) // Uma ação por tipo por listing
  @@index([tenant_id])
  @@index([listing_id])
  @@index([action_type])
  @@map("applied_actions")
}

// DIA 08: Tabela de jobs para sync automático (DBQueue)
model SyncJob {
  id           String          @id @default(uuid())
  tenant_id    String
  type         SyncJobType
  status       SyncJobStatus   @default(queued)
  priority     SyncJobPriority @default(background)
  payload      Json
  lock_key     String
  run_after    DateTime        @default(now()) @db.Timestamptz(3)
  attempts     Int             @default(0)
  max_attempts Int             @default(3)
  started_at   DateTime?       @db.Timestamptz(3)
  finished_at  DateTime?       @db.Timestamptz(3)
  error        String?         @db.Text
  created_at   DateTime        @default(now()) @db.Timestamptz(3)
  updated_at   DateTime        @updatedAt @db.Timestamptz(3)

  tenant Tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  // HOTFIX: Índice único parcial para dedupe de TENANT_SYNC
  @@unique([lock_key], map: "sync_jobs_lock_key_unique")
  @@index([status, priority, run_after])
  @@index([tenant_id, status])
  @@index([lock_key, status])
  @@map("sync_jobs")
}

// DIA 09: Feedback do usuário sobre hacks sugeridos
model ListingHack {
  id           String    @id @default(uuid())
  tenant_id    String
  listing_id   String
  hack_id      String // Ex: "ml_full_shipping", "ml_bundle_kit", etc.
  status       String // "confirmed" | "dismissed"
  notes        String?   @db.Text
  confirmed_at DateTime?
  dismissed_at DateTime?
  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt

  tenant  Tenant  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listing_id], references: [id], onDelete: Cascade)

  @@unique([listing_id, hack_id]) // Um feedback por hack por listing
  @@index([tenant_id, updated_at(sort: Desc)])
  @@index([listing_id])
  @@index([hack_id])
  @@index([status])
  @@map("listing_hacks")
}
